---
title: "Statexpres's: Rapid Development with Mentalab Explore - Advanced Signal Exploration in Sleep EEG (statexpres.com/sleep)"
output:
  flexdashboard::flex_dashboard:
    storyboard: TRUE
    always_allow_html: yes
  pdf_document:
    classoption: landscape
    documentclass: ar-1col
    header-includes: \usepackage{fancyhdr,tabu, courier,chngcntr,longtable, graphicx,float,natbib,geometry}
    keep_tex: TRUE
    fig_caption: yes
    number_sections: yes
    always_allow_html: yes
runtime: shiny
---

<style>
  .storyboard-nav .sbframelist {
        margin: 0 auto;
        width: 94%;
        height: 90px;
        overflow: hidden;
        text-shadow: none;
        margin-bottom: 3px;
        margin-top: 3px;
  }
  .storyboard-nav .sbnext, .storyboard-nav .sbprev {
        float: left;
        width: 20px;
        height: 20px;
        font-size: 20px;
  }
</style>

```{r server_environement, include=FALSE}
## Create Folders and source them
## sudo apt-get install tk-dev
## sudo apt-get install fftw-dev
## sudo apt-get install libcgal-dev libglu1-mesa-dev libglu1-mesa-dev

# mainDir<-getwd()
# create_folder<-function(x)ifelse(!dir.exists(file.path(getwd(), x)), dir.create(file.path(getwd(), x)), FALSE)
# create_folder('Data')
# create_folder('Report')
# create_folder('Plots')
# create_folder('EDF')
```

```{r r_and_shiny_environement, include=FALSE}
################################ load and install of r packages ###############################
loadpackage<-function(x){
  for(i in x){
    if(!(i %in% rownames(installed.packages()))){
    eval(parse(text=paste0("install.packages(\"",i,"\", repos=\'http://cran.us.r-project.org\')")))
    eval(parse(text=paste0("library(\"",i,"\")")))}
    else{eval(parse(text=paste0("library(\"",i,"\")")))}
  }
}
################################ POSSIBLE UNNESSECARY PACKAGES / CHECK SORT FOR READABILITY ##############################
loadpackage(c("plyr","dplyr","ggplot2","knitr","broom","ggfortify","future","kableExtra","xts","eegUtils","dlm","forecast","signal",
              "rmarkdown","plotly","visNetwork","Rssa","RHRV","data.table","DT","shinyTime","shinyWidgets","dygraphs","ggplotify","cowplot","tidyr"))

demoMode<<-F ######################## SHOULD BE DELETED 

################################ set default code-chunk parameters
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE,
                      fig.align = 'center', fig.pos = 'htbp', results = 'asis')
options(scipen = 999)# no exponentials-plain values
options(shiny.maxRequestSize=5000*1024^2)#Max Upload Size
options(shiny.Trace=T)
################################ Default output format (shiny-html first, statitic-Pdf later)
if(!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))){
  outputoption<<-knitr::opts_knit$get("rmarkdown.pandoc.to")
}else{outputoption<<-"html"}
shiny_running <<- function()identical(rmarkdown::metadata$runtime, 'shiny')&outputoption!="latex"
if(!shiny_running()){
  reactiveValues<-function(...)list(...)
}

################################# FIND AND SET BASE DIRECTORY
if(outputoption!="html"){
  if(outputoption!="latex"){
  mainDir<<-getwd()
  }else{
    mainDir<<-getwd()
    # mainDirsplit<-strsplit(mainDir,"/")[[1]]
    # mainDir<-paste(mainDirsplit[-length(mainDirsplit)],collapse="/")
  }
}else{
  if(outputoption=="html")
    # mainDir<<-"/srv/shiny-server/Test/"
  mainDir<<-getwd()
    #demoMode=T
    # mainDir<-"/home/sweiss/Mentalab/"
}
################################# IF STATIC USE UNSTATIC FUNCTION AS LIST -> FOR DEBUG PURPOSES 
if(!shiny_running()){
  reactiveValues<<-function(...)list(...)
}
```

```{r python_environment}
####################### Setup Python Environement in Reticulate #######################
####################### CURRENTLY NOT MAINTAINED -> USED IS WHAT IS PROVIDED DEFAULT BY RETICULATE ###############
reticulate::use_python(reticulate::py_config()[[1]],required = T)
library(reticulate)
#reticulate::repl_python()
# conda_create("final")
#use_condaenv("final")
# reticulate::repl_python()
# explorepy <- reticulate::import_from_path("explorepy",path="C:/Users/royde/Anaconda3/Lib/site-packages")
# visbrain<-reticulate::import("visbrain",delay_load = T)
# scipy <- reticulate::import("scipy",delay_load = T)
# numpy <- reticulate::import("numpy",delay_load = T)
#conda_install("MENTALAB", "explorepy")
```

```{r define_functions}
####################### FILES NEED TO BE UPDATED
reticulate::source_python(paste0(mainDir,"/EEG.py")) ###### LSL STREAM MISSING
source(paste0(mainDir,"/helpers.R")) 
source(paste0(mainDir,"/ui.R"))
source(paste0(mainDir,"/fixed_frequency.R"))

####################### MANY UI FUNCTIONS REMOVED FROM HERE -> POSSIBLE BUG? #######################

```

    
<!-- \lhead{MentaLab's Signal Evaluation \linebreak {\leftmark}  } -->

\clearpage

<!-- ### Signal Source -->

```{r default_EEG_and_Graph_Object}
source(paste0(mainDir,"/constructor.R"))
```

<!-- \begin{tcolorbox}[colback=lhi!30,%gray background -->
<!--                 colframe=lhi!60,% black frame colour -->
<!--                 arc=1mm, auto outer arc,] -->
<!-- MentaLab's Signal Evaluation employes recent signal processing tools, to evaluate ECG and EEG data.     -->
<!-- Furthermore it holds relevant citation and customizable output formats.     -->
<!-- It is extandable by Python and R data analysis methods and curated by professional biostatisticians and medical experts.     -->
<!-- \end{tcolorbox} -->

### Input - data is assumed to be in Voltage and will be converted based on biosource, initial rounding to one microvolt.
<!-- {.sidebar} -->

```{r}


if(shiny_running()){
  output$dygraph<-
    renderDygraph({
      if(ExG$newfile){
          d<-dygraph(ExG$disp) %>% dyAxis("y", label = "Electric Potential (EEG-uV / E(CMO)G-mV)",valueRange=c(-50,50)) %>%
            dyRangeSelector(height = 90) %>%
          dyOptions(axisLineWidth = 1.5, drawGrid = FALSE) %>%
            dyLegend(show = "never")
          ExG$newfile=F
      }else{
        ## Seperate Channel by normalizing to IQR and adding a positional vector -"the matrix"
        d<-dygraph(ExG$disp) %>% dyAxis("y", label = "Electric Potential (V)",valueRange=c(-50,50)) %>%
          dyRangeSelector(height = 90,retainDateWindow=T) %>% dyLegend(show = "never") %>%
          dyOptions(axisLineWidth = 1.5, drawGrid = FALSE,connectSeparatedPoints=T) %>% dyCallbacks(
            annotationClickHandler=
          "function(ann, point, dg, event){
          ann.div.style.backgroundColor =  '#ddd';
          var message=ann.text;
          Shiny.onInputChange('downRater',0);
          Shiny.setInputValue('downRater',message);}")
    }
    if("Bandpower" %in% input$disp_event){
      # Take Bandpower columns - always last ones
      dn<-colnames(ExG$disp)[(ncol(ExG$disp)-4):(ncol(ExG$disp))]
        for(i in 1:length(dn)){
          #display them on other y axis
          d<-d %>% dySeries(dn[i], axis = 'y2',stepPlot = F,
                   color=c("#edf8fb","#b3cde3","#8c96c6","#8856a7","#810f7c")[i])%>%
            dyAxis("y2", label = "Bandpower (%)",valueRange=c(0,100))
        }
    }
    if("Stages" %in% input$disp_event){
      for(i in 1:(nrow(ExG$stages))){
        if(any(ExG$stages[i,1] %in% c("W","S1","S2","S3","REM","A") )){
          ## Get the closest index value of the displayed time series
          ## Write the annotation there - otherwise does not show an annotation bc timestamp might be missing
            d= d %>% dyAnnotation(index(ExG$disp)[
              which(abs(index(ExG$disp)-ExG$stages[i,2])==min(abs(index(ExG$disp)-ExG$stages[i,2])))],
              text=ExG$stages[i,1],tooltip = as.character(i),width=30,height=30)
          }
      }
    }
    if("Sleep Spindles" %in% input$disp_event){
      for(i in 1:(nrow(ExG$spindles))){
        ## same as above, closest existing timestamp, events are the Sleep Spindles only atm
        d= d %>% dyAnnotation(index(ExG$disp)[
          which(abs(index(ExG$disp)-ExG$spindles[i,2])==min(abs(index(ExG$disp)-ExG$spindles[i,2])))],
          text="Sp",attachAtBottom =T,width=20,height=20)
      }
    }
      if("QRS-Complex" %in% input$disp_event){
      for(i in 1:(nrow(ExG$qrs))){
        ## same as above, closest existing timestamp, events are the Sleep Spindles only atm
        d= d %>% dyAnnotation(index(ExG$disp)[
          which(abs(index(ExG$disp)-ExG$qrs[i,2])==min(abs(index(ExG$disp)-ExG$qrs[i,2])))],
          text="QRS",attachAtBottom =T,width=20,height=20)
      }
    }
    d
  })
}

### FIRST PANEL UI ELEMENTS PLACEMENT
if(shiny_running()){
  fillCol(
    fillRow(
      actionButton("upload","Upload new Data ... "),
        renderUI({
          chansels=colnames(ExG$ts)
          pickerInput(
          inputId = "disp_chan",
          choices =chansels,
          options = list(title = "Channels",
                         `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          )
        }),
        pickerInput(
          inputId = "disp_event",
          choices = c("Bandpower","Stages","Sleep Spindles","QRS-Complex"),
          options = list(title = "Events",
                         `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          ),
        renderUI({
          sel_choices=colnames(ExG$rssa)
          pickerInput(
            inputId = "disp_ssa",
            choices = sel_choices,
            options = list(title = "Clusters",
                           `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          )
        }),
        switchInput(inputId = "sep_chan",
                    label = "parallel lines", value=F),flex=c(1,2,2,2,1)),
    ### INPUTS FINISHED -> NEXT COLUMN: GRPAHIC
    dygraphOutput("dygraph")
    ,flex = c(1,10))
}else{
  ## STATIC DISPLAY HYPNOGRAM
  # it's W, REM, S1, S2, S3,
  # d=data.frame(x=c(1,2,4,5,7,8,9), y=c(1,2,3,5,6,7,9))
  d=EXG$stages
  d[,1]=factor(d[,1],levels = c("S3","S2","S1","REM","W","A"))
  colnames(d)=c("y","x")
ggplot() +
geom_step(data=d, mapping=aes(x=x, y=y),group=1)+theme_classic()
}

```


```{r,file_observer}

# ## Input controls first page, used when uploaded only
# if(shiny_running()){
#   dateInput("rec_date", label="Start Date", value = NULL, min = NULL, max = NULL,
#   format = "yyyy-mm-dd", startview = "month", weekstart = 0,
#   language = "en", width = NULL, autoclose = TRUE,
#   datesdisabled = NULL, daysofweekdisabled = NULL)
# }
#
# if(shiny_running()){
#   textInput("rec_time", "Start Time (xx:xx or xx:xx:xx)", value = init.time, width = NULL,
#   placeholder = NULL)
# }
#
# if(shiny_running()){
# sliderInput("srate", label = "Sampling Frequency", min = 0,max = 400, value = 250,step=10)
# }
#
# if(shiny_running()){
#   fileInput("static_data", "Upload Data (EDF/CSV/BIN):", multiple = F, accept = c(".csv",".edf",".BIN"),
#       width = NULL, buttonLabel = "Browse...",
#       placeholder = "No file selected")
# }

## initial extra modal for difficult parameter entry only
# if(shiny_running()){
# observeEvent(input$upload,{
#   showModal(modalDialog(
#
#
#   ,
#
#   )
# })

## Include Export and Import Options, funcitons is faulty
## DATA upload actions, currently only EDF and csv
if(shiny_running()){
  observeEvent(input$static_data,{
    print("LOADING DATA")
    if(any(grepl(".csv",input$static_data))){
      tmp=fread(input$static_data$datapath)
    }
    if(any(grepl(".BIN",input$static_data))){
      py$import_explorepy(nput$static_data$datapath)
    }
    ExG$srate=as.numeric(input$srate)
    ExG$posix=as.POSIXct(paste(input$rec_date,input$rec_time))
    if(any(grepl(".edf",input$static_data))){
      tmp=import_raw(input$static_data$datapath)
      ExG$srate=tmp[["srate"]]
      tmp=tmp[["signals"]]
    }
    ExG$ts=as.xts(data.frame(tmp),
                seq(ExG$posix,
                    by=1/ExG$srate, length=nrow(data.frame(tmp))))
      # get column names
      graph_data$nodes=update_nodes(base.nodes,tmp)
      biosigs=subset(graph_data$nodes,group=="biological")
      physigs=subset(graph_data$nodes,group=="physical")
      digsigs=subset(graph_data$nodes,group=="digital")
      #

      graph_data$edges=setNames(data.frame(matrix(ncol = 3, nrow = 0)), c("from", "to","id"))
      ExG$freq=ExG$ts
      colnames(ExG$freq)=paste0("Filtered",colnames(ExG$ts))
      ExG$orig.chan=downsample(ExG$freq,60*15)
      ExG$orig.ssa=downsample(ExG$freq,60*15)
      ExG$orig.disp=downsample(ExG$freq,60*15)
      ExG$disp=downsample(ExG$freq,60*15)
      ExG$newfile=T
      #
      # ExG$orig.disp=tmp
      # ## reset UI elements below
      # ExG$sight="bird"
       a=first(index(ExG$orig.disp))
       b=last(index(ExG$orig.disp))
      # tmp=downsample(window(ExG$orig.disp,start=a,end=b),250*60)
       ExG$resol=c(a,b)
      # ExG$disp=tmp
      # ExG$newfile=T
    ExG$stages=data.frame("Sleep State (A, W, S1, S2, S3, REM)"="W",
                        "Time (xx:xx or xx:xx:xx)"=first(seq(ExG$posix,by=1/ExG$srate,length=nrow(ExG$ts))),
                        stringsAsFactors = F)
    graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1)
    graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2)
    graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3)
    graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4)
    print("READIN WORKED")
  })

observeEvent(input$srate,{
  ExG$srate=input$srate
})
}

if(shiny_running()){
observeEvent(input$upload,{
  showModal(modalDialog(
    dateInput("rec_date", label="Start Date", value = NULL, min = NULL, max = NULL,
  format = "yyyy-mm-dd", startview = "month", weekstart = 0,
  language = "en", width = NULL, autoclose = TRUE,
  datesdisabled = NULL, daysofweekdisabled = NULL),
  textInput("rec_time", "Start Time (xx:xx or xx:xx:xx)", value = init.time, width = NULL,
  placeholder = NULL),
  numericInput("srate","Sampling Frequency",value=250,min=1,max=1000),
  fileInput("static_data", "Upload Data (EDF/CSV/BIN):", multiple = F, accept = c(".csv",".edf",".BIN"),
      width = NULL, buttonLabel = "Browse...",
      placeholder = "No file selected"),
  switchInput(inputId = "rec_btn",label = "Bluetoot device name", labelWidth = "80px"),
  renderTable(head(ExG$ts)),size="l"
  )
)
})
}

if(shiny_running()){
  observeEvent(input$rec_btn,{
     
    plan(multisession)
    ############ MOCKUP SCRIPT ##################
    v %<-% {
      tmp=lorenz(sigma = 10, beta = 8/3, rho = 28,
                start = c(5, 5, 5), time = seq(0, 10000, by = 0.01),
                do.plot = F)
      tmp
      }
    Sys.sleep(5)
    tmp=data.frame(Fp1=v[["x"]],F1=v[["y"]],C3=v[["z"]])
    
    ########### COMING SOON - REAL SCRIPT #########
    while(input$rec_btn==T){ ### WHILE RECORDING
      # reticulate::source_python(paste0("C:/Users/royde/Desktop/explore_connect.py")) ### CONNECT TO DEVICE AND
      v %<-% { ### EVALUATE PARALLEL
        .libPaths("C:/Users/royde/Documents/R/win-library/4.0") ### GRAB DEFAULTS
        library(reticulate) ### LOAD EM
        mainDir<<-getwd()
        source_python(paste0(mainDir,"/EEG.py")) ### CREATE LSL STREAM  
        py$connect_explore()
      }
      v %<-% { ### EVALUATE PARALLEL
        .libPaths("C:/Users/royde/Documents/R/win-library/4.0") ### GRAB DEFAULTS
        library(reticulate) ### LOAD EM
        mainDir<<-getwd()
        source_python(paste0(mainDir,"/EEG.py")) ### CREATE LSL STREAM  
        tmp=c()
        for(i in 1:60){ ### FOR EACH 5 seconds GRAB DATA
          tmp=c(tmp,py$explore_df())
        }
        #tmp  ### REORIENT DATA
        #tmp  ### GIVE IT BACK
      }
      ### ALL 5 SECONDS GRAB DATA AND THROW ON GRAPH UNTIL BROKEN
      ### POSSIBLY FIX BY EXG$hold  ??
    }
    
# init.channels<<-colnames(tmp)
    ExG$ts=as.xts(data.frame(tmp),
                seq(ExG$posix,
                    by=1/ExG$srate, length=nrow(data.frame(tmp))))
    ExG$srate=as.numeric(input$srate)
    ExG$posix=as.POSIXct(paste(input$rec_date,input$rec_time))
      # get column names
      graph_data$nodes=update_nodes(base.nodes,tmp)
      biosigs=subset(graph_data$nodes,group=="biological")
      physigs=subset(graph_data$nodes,group=="physical")
      digsigs=subset(graph_data$nodes,group=="digital")
      #

      graph_data$edges=setNames(data.frame(matrix(ncol = 3, nrow = 0)), c("from", "to","id"))
      ExG$freq=ExG$ts
      colnames(ExG$freq)=paste0("Filtered",colnames(ExG$ts))
      ExG$orig.chan=downsample(ExG$freq,60*15)
      ExG$orig.ssa=downsample(ExG$freq,60*15)
      ExG$orig.disp=downsample(ExG$freq,60*15)
      ExG$disp=downsample(ExG$freq,60*15)
      ExG$newfile=T
      #
      # ExG$orig.disp=tmp
      # ## reset UI elements below
      # ExG$sight="bird"
       a=first(index(ExG$orig.disp))
       b=last(index(ExG$orig.disp))
      # tmp=downsample(window(ExG$orig.disp,start=a,end=b),250*60)
       ExG$resol=c(a,b)
      # ExG$disp=tmp
      # ExG$newfile=T
    ExG$stages=data.frame("Sleep State (A, W, S1, S2, S3, REM)"="W",
                        "Time (xx:xx or xx:xx:xx)"=first(seq(ExG$posix,by=1/ExG$srate,length=nrow(ExG$ts))),
                        stringsAsFactors = F)
    graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1)
    graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2)
    graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3)
    graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4)

# w %<-% {
#   .libPaths("C:/Users/royde/Documents/R/win-library/4.0")
#   library(reticulate)
#   source_python(paste0("C:/Users/royde/Desktop/explore_dataframe.py"))
#   b=c()
#   for(i in 1:60){
#     b=c(b,py$explore_df())
#   }
#   b
# }
# source_python(paste0("C:/Users/royde/Desktop/explore_dataframe.py"))
# liveish_data <- reactive({
#   invalidateLater(100)
#   b=c()
#   for(i in 1:60){
#     b=c(b,py$explore_df())
#   }
#   b=b[-1]
# 
#   if(length(w)%%(8*3) !=0){
#     b=c(rep(0,(8*3)-length(b)%%(8*3)),b)
#   }
#   b=matrix(b,ncol=8)
#   b=data.frame(b)
#   liveish_data=rbind(liveish_data,b)
#   Disp$disp=liveish_data
# })

# w %<-% {
#   .libPaths("C:/Users/royde/Documents/R/win-library/4.0")
#   library(reticulate)
#   source_python(paste0("C:/Users/royde/Desktop/explore_dataframe.py"))
#   b=c()
#   for(i in 1:60){
#     b=c(b,py$explore_df())
#   }
#   b
# }
# w=w[-1]
# 
# if(length(w)%%(8*3) !=0){
#   w=c(rep(0,(8*3)-length(w)%%(8*3)),w)
# }
# w=matrix(w,ncol=8)
# 
# init.ExG=data.frame(Ch1=w[,1],
#                     Ch2=w[,2],
#                     Ch3=w[,3],
#                     Ch4=w[,4],
#                     Ch5=w[,5],
#                     Ch6=w[,6],
#                     Ch7=w[,7],
#                     Ch8=w[,8])
## 100 datapoints per second


  })
}

```


### Source & Filter - add edges from channels to biosources, select biosources and apply filter settings


```{r}
# tag$script('$(document).on("keypress",function(e) {
#               Shiny.onInputChange("keyinput",e.which);
#              })')
```


```{r,visnetwork}

if(shiny_running()){
  ## Graph Network - fontawesome not working, some manipulations should be disaabled, clusters not displayed
  output$visnet<-renderVisNetwork({
    visNetwork(graph_data$nodes,graph_data$edges) %>%
      visOptions(nodesIdSelection = list(enabled=T,values = c(1:4)),manipulation = list(
    enabled= T,
    initiallyActive= T,
    addNode= F,
    addEdge= T,
    editEdge= F,
    deleteNode= F,
    deleteEdge= T
    )) %>%visInteraction(multiselect=T,
                         dragNodes = T,
                         dragView = T,
                         zoomView = T) %>%
      visGroups(groupname = "digital", shape = "icon",
            icon = list(code = "f31b", size = 75,face = 'Ionicons',color="black")) %>%
      visGroups(groupname = "physical", shape = "icon",
                icon = list(code = "f3a7", size=75,face = 'Ionicons',color="red"))%>%
      visGroups(groupname = "biological", shape = "icon",
                icon = list(code = c('f493'), size=75,color="green",face = 'Ionicons'))  %>%
      visGroups(groupname = "Component", shape = "icon",
                icon = list(code = "f2e9", size = 25,color="orange",face = 'Ionicons')) %>%
      visGroups(groupname = "Cluster", shape = "icon",
                    icon= list(code = "f25c", size = 75,color="blue",face= 'Ionicons')) %>% addIonicons()%>% visEdges(arrows = "to") %>%
  visHierarchicalLayout( levelSeparation = 200,nodeSpacing=50,treeSpacing=100)

  })

  visNetworkOutput("visnet")
}

# visEvents(select = "function(nodes) {
#                 Shiny.onInputChange('current_node_id', nodes.nodes);
#                 ;}") %>%
# %>%
#                  visEvents(select = "function(nodes) {
#                 Shiny.onInputChange('current_node_id', nodes.nodes);
#                 ;}")

  # observeEvent(input$current_node_id, {
  #   visNetworkProxy("visnet") %>%
  #     visGetNodes()
  # })

if(shiny_running()){
## Watch Manipulation of network - also implement renaming columns
## Some features are implemented but disabled by the graph network
## No real ?eval expressions just some features (hard) evaluated
  observeEvent(input[["visnet_graphChange"]],{
    print("CHANGE APPLIES")
    # If the user added a node, add it to the data frame of nodes.
    if(input[["visnet_graphChange"]][["cmd"]] == "addNode") {
      temp = bind_rows(
        graph_data$nodes,
        data.frame(id = input[["visnet_graphChange"]]$id,
                   label = input[["visnet_graphChange"]]$label,
                   stringsAsFactors = F)
      )
      graph_data$nodes = temp
    }
    # If the user added an edge, add it to the data frame of edges.
    else if(input[["visnet_graphChange"]]$cmd == "addEdge") {
      tmp = bind_rows(
        graph_data$edges,
        data.frame(id=(nrow(graph_data$edges)+1) ,
                   from =input[["visnet_graphChange"]]$from,
                   to = input[["visnet_graphChange"]]$to,
                   stringsAsFactors = F)
      )
      ## if eeg changed
      if(length(findexg(graph_data$nodes,graph_data$edges,1))!=
         length(findexg(graph_data$nodes,tmp,1))){
        ## to and from cases
        if(as.character(input[["visnet_graphChange"]]$to) %in%
           as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$to )])
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000)
          }else{
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$from )])
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000)
             }
      }
      if(length(findexg(graph_data$nodes,graph_data$edges,2))!=
         length(findexg(graph_data$nodes,tmp,2))|
         length(findexg(graph_data$nodes,graph_data$edges,3))!=
         length(findexg(graph_data$nodes,tmp,3))|
         length(findexg(graph_data$nodes,graph_data$edges,4))!=
         length(findexg(graph_data$nodes,tmp,4))){
          if(as.character(input[["visnet_graphChange"]]$to) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$to) ])
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*1000
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*1000
          }else{
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$from )])
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000)
             }
         }

      graph_data$edges = tmp
    }
    # If the user edited a node, update that record.
    else if(input[["visnet_graphChange"]]$cmd == "editNode") {
      temp = graph_data$nodes
      temp$label[as.character(temp$id) == as.character(input[["visnet_graphChange"]]$id)] = as.character(input[["visnet_graphChange"]]$label)
      graph_data$nodes = temp
      physigs=as.character(subset(graph_data$nodes,group=="physical")$label)
      colnames(ExG$ts)=physigs
      colnames(ExG$freq)=paste0("Filtered",physigs)

    }
    # If the user edited an edge, update that record.
    else if(input[["visnet_graphChange"]]$cmd == "editEdge") {
      temp = graph_data$edges
      temp$from[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$from
      temp$to[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$to
      graph_data$edges = temp
    }
    # If the user deleted something, remove those records.
    if(input[["visnet_graphChange"]]$cmd == "deleteElements") {
      globtmp=graph_data$nodes
      for(node.id in input[["visnet_graphChange"]]$nodes) {
        tmp = globtmp
        tmp = tmp[tmp$id != node.id,]
        globtmp = tmp
      }
      graph_data$nodes=globtmp
      globtmp=graph_data$edges
      for(edge.id in input[["visnet_graphChange"]]$edges) {
        tmp = globtmp
        tmp = tmp[tmp$id != edge.id,]

        globtmp = tmp
      }
      tmp=globtmp
      if(length(findexg(graph_data$nodes,graph_data$edges,1))!=
         length(findexg(graph_data$nodes,tmp,1))){
      for(i in input[["visnet_graphChange"]]$edges){
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])]
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])]
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
      }
      }
      if(length(findexg(graph_data$nodes,graph_data$edges,2))!=
         length(findexg(graph_data$nodes,tmp,2))|
         length(findexg(graph_data$nodes,graph_data$edges,3))!=
         length(findexg(graph_data$nodes,tmp,3))|
         length(findexg(graph_data$nodes,graph_data$edges,4))!=
         length(findexg(graph_data$nodes,tmp,4))){
        for(i in input[["visnet_graphChange"]]$edges){
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])]
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])]
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
        }
      }
      graph_data$edges=tmp
    }
      graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1)
      graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2)
      graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3)
      graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4)
      print("CHANGE ENDED")
})
}

# renderPrint(print(visGetSelectedNodes("")))
  # observeEvent(input$current_node_id, {
  #   visNetworkProxy("network_proxy") %>%
  #     visGetNodes()
  # })

# observeEvent(input$visnet_selected,{
#   if(any(input$visnet_selected %in% graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"])){
#
#     selicks=subset(graph_data$nodes,group=="Cluster")[graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"] %in% input$visnet_selected,]
#
#     update_nodes_components()
#
#   }
#
# })


```


```{r,filter_apply}

if(shiny_running()){
observeEvent(input$filter_button,
             {
    if(!is.null(input$visnet_selected)&any(input$visnet_selected %in% biosigs$id)){
      vis_sub=input$visnet_selected[input$visnet_selected %in% biosigs$id]

      chans=graph_data$nodes$id %in% input$visnet_selected

      filt_ch=as.character(graph_data$nodes[chans,"label"])

      # if notch filtered, create new edge signal to filter
      if(input$stoppoint!=0){
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "Notch"],
          title=paste0("<p>Notch:", input$stoppoint,"</p>"),
          value=1,stringsAsFactors = F))
      }
      ## same for passband
      if(any(input$passband!=c(0,250))){
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "Low Pass"],
          title=paste0("<p>Low Pass:", input$passband[1],"</p>"),
          value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F))
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "High Pass"],
          title=paste0("<p>High Pass:", input$passband[2],"</p>"),
          value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F))
      }
      ## apply filter

      tmp=freq_filter(ExG$ts[,graph_data[[filt_ch]]],ExG$srate,
                      as.numeric(as.character(input$stoppoint)),
                      input$passband,graph_data[[filt_ch]])

      colnames(tmp)<-paste0("Filtered",colnames(tmp))
      ExG$freq[,(colnames(ExG$freq) %in% paste0("Filtered",graph_data[[filt_ch]]))]=tmp

      # tmp2=ExG$freq[,!(colnames(ExG$freq) %in% paste0("Filtered",graph_data[filt_ch]))]
      # ExG$freq<-as.xts(tmp[,(colnames(tmp) %in% paste0("Filtered",graph_data[filt_ch]))],
      #              seq(ExG$posix, by=1/ExG$srate,length=nrow(tmp)))
      # ExG$freq=cbind(ExG$freq,tmp2)
      # ExG$freq[,order()]

      ## Change width of edge
      # graph_data$edges
    }

})
}
```

***

```{r, filter_ui}
if(shiny_running()){
  selectInput("stoppoint", label = "Select (Notch) Frequency to silence:",
              choices = c(0, 50, 60), selected = 0)
}

if(shiny_running()){
  renderUI({sliderTextInput(
   inputId = "passband",
   label = "Select Band to pass:",
    choices = c(seq(0.1,10,by=0.1),seq(10,round(ExG$srate/2,0))),
selected = c(2, 30),
   from_min = 0.1,
    from_max = 10,
   to_min = 30,
   to_max = 100,
   grid = TRUE
)})
}

# renderPrint( {
#     if (!is.null(input$current_node_id) && !is.null(input$visnet_nodes)) {
#       print(input$current_node_id)
#       # info <- data.frame(matrix(unlist(),
#       #                           ncol = dim(nodes)[1], byrow = T),
#       #                    stringsAsFactors = FALSE)
#       # colnames(info) <- colnames(nodes)
#       # info[info$id == input$current_node_id, ]
#     }
#   })


# renderPrint(print(visNetworkProxy("visnet")%>%visGetSelectedNodes()))
#
# if(shiny_running()){
#   renderUI({
#   spindle_choices=c(colnames(ExG$freq),paste0("Clust",names(ExG$gssa)))
#
#   pickerInput(
#     inputId = "",
#     label = "Select Channels/Sources for Spindle Detection",
#     choices =spindle_choices,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10
#   ),
#   multiple = F
#   )
#   })
# }



if(shiny_running()){
  actionButton("filter_button", "Apply Filter / Bandpower")
}



```

```{r}

# renderPrint(print(c(filter_value(graph_data$nodes,graph_data$edges,s="EEG"),filter_value(graph_data$nodes,graph_data$edges,s="ECG"),filter_value(graph_data$nodes,graph_data$edges,s="EOG"),filter_value(graph_data$nodes,graph_data$edges,s="EMG"))))
if(shiny_running()){
  textInput("pat_desc", "Patient Description",
              value = "John Doe, M, 25, Apnoe, no Medication", placeholder = "Name of Patient")
}

if(shiny_running()){
  downloadButtonRmd("downloadEDF", "Download EDF")
}

# observeEvent(input$edf_create,{
#   showModal(modalDialog(
#   ,
#
#       )
#     )
# })

```


```{r,edfoutput,echo=F}
################################## CREATE EDF BY PATIENT DESCRIPTION #####################
################################## LOADING SCREEN MISSING AND NOT WORKING IF FUNCTION IN DIFFERENT SCRIPT #####################
if(shiny_running() ){
  output$downloadEDF <- downloadHandler(
    filename = function(){paste0(input$pat_desc,"_",format(as.Date(ExG$posix),format="%d.%m.%y"),".edf")},
    content = function(file){
      fn=signals2EDF(mainDir=mainDir,pat_desc=input$pat_desc,ExG=ExG,graph_data=graph_data)
      file.rename(fn, file)
    }
  )
}
```

### Sleep Spindles and QRS Detection

```{r}
############################### HRV ANALYSIS ###################################
############################### SHOWS ERROR MESSAGE BEFORE QRS DETECTION ###################################

if(shiny_running()){
  fillCol(
    renderTable({
      res=as.data.frame(ExG$hrv[[2]]["TimeAnalysis"])
      colnames(res)=unlist(lapply(strsplit(colnames(res),"TimeAnalysis."),function(x)x[[2]]))
      round(res,0)
      }),
    fillRow(
      renderPlot({PlotSinglePowerBand(ExG$hrv[[1]], 1, "LF/HF",doPlot=T,
                                      main="heart related stress adaption",                 
                                      eplim=c(min(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),
                                              max(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF)))
        }),
      renderPlot({
        PoincarePlot(ExG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T)
        })
      ),flex=c(1,5)
  )
}else{
  ############################### FOR DISPLAY IN REPORT ###################################
  ############################### CURRENTLY NOT WORKING ###################################
  kable(as.data.frame(EXG$hrv[[2]]["TimeAnalysis"]))
  PlotSinglePowerBand(EXG$hrv[[1]], 1, "LF/HF",doPlot=T,main="heart related stress adaption",                     eplim=c(min(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),max(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF)))
  PoincarePlot(EXG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T)
}

```

***

```{r}
if(shiny_running()){
  sliderInput("L", label = "Window Length", min = 10,max = 50, value = 30,step=1)
}

if(shiny_running()){
  # dropdown(
  # tags$h3("List of Input"),
  renderUI({
  eeg_choicings=c(graph_data$EEG)

  pickerInput(
    inputId = "eeg_ana",
    label = "Select Channel for Sleep Spindles & Baandpower",
    choices =c(eeg_choicings),
    options = list(
    `actions-box` = TRUE,
    size = 10
  ),
  multiple = F
  )
  })
}


if(shiny_running()){
  # dropdown(
  # tags$h3("List of Input"),
  renderUI({
    ecg_choicings=c(graph_data$ECG)

  pickerInput(
    inputId = "ecg_ana",
    label = "Select Channel for QRS Detection",
    choices =ecg_choicings,
    options = list(
    `actions-box` = TRUE,
    size = 10
  ),
  multiple = F
  )
  })
}
if(shiny_running()){
  actionButton("ana_button", label = "Analyze")
}

```

### Singular Spectrum Analysis - Manual Clustering: Click on Component (red square) -> Click on Component in New Cluster

```{r, staging table and SSA plot}
if(shiny_running()){
  output$stages<-renderDT({
    DT::datatable(
      data.frame(
        cbind(
          ExG$stages[,1],
          strftime(ExG$stages[,2],format="%H:%M:%S")),
        stringsAsFactors = F),
      editable=F,options = list(dom = 't'),
      colnames = c("Stage","Time"))
    })
}
```

```{r}
### OBSERVER FOR EDITING
if(shiny_running()){
  #Editable stages
  observeEvent(input[["stages_cell_edit"]],{
    tmp=input[["stages_cell_edit"]]
    if(tmp$col==2){
      if(length(strsplit(tmp$value,":")[[1]])>=2){
        if(!to_day(ExG$posix,tmp$value)){
          ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,tmp$value))
        }else{
          ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),tmp$value))
        }
      }
      if(length(strsplit(tmp$value,":")[[1]])==2){
        if(!to_day(ExG$posix,tmp$value)){
          ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,paste0(tmp$value,":00")))
        }else{
          ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),paste0(tmp$value,":00")))
        }
      }
    }
    else{
    ExG$stages[tmp$row,tmp$col]<-tmp$value
    }
    ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),]
  })
}
```


```{r}
if(shiny_running()){
output$telco<-renderPlot({
if(!is.null(input$ssa_channel) & ExG$hold==0){
  ###################GRAPHIC FOR ONE STAGE WITH ALL COMPONENTS
#   if(length(input$stages_rows_selected)!=1){
#     if(input$time_real==F){
#   p= ggplot()+geom_line(data=ExG$df_res,aes(x=ind,y=Value))+
#     geom_line(data=ExG$df_res,aes(x=ind,y=Value,group=Comp,color=Comp))+
#     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+
#     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
#   }else{
#   p= ggplot()+geom_line(data=ExG$df_res2,aes(x=ind,y=Value))+
#     geom_line(data=ExG$df_res2,aes(x=ind,y=Value,group=Real,color=Real))+
#     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+
#     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
#
#     }
#   p
# }else{
#####################GRAPHIC FOR MANY STAGE FOR EACH CLUSTER

  if(input$time_real==F){
 # p=ggplot()+geom_line(
 #        data=ExG$df_res[ExG$df_res$Column==input$stages_rows_selected,],
 #        aes(x=ind,y=Value,group=Comp,color=Comp))+
 #        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+
 #   geom_rect(data = ExG$df_res[ExG$df_res$Column==input$stages_rows_selected & ExG$df_res$Comp %in% ExG$pan[2],],
 #                          fill = NA, colour = "red", xmin = -Inf,xmax = Inf,
 #            ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
 #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")

 p=ggplot()+geom_line(
        data=ExG$df_res,
        aes(x=ind,y=Value,group=Comp,color=Comp))+
        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+
   geom_rect(data = ExG$df_res[ExG$df_res$Comp %in% ExG$pan[2],],
                          fill = NA, colour = "red", xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")

    }else{
 # p=ggplot()+geom_line(
 #        data=ExG$df_res2[ExG$df_res2$Column==input$stages_rows_selected,],
 #        aes(x=ind,y=Value,group=Real,color=Real))+
 #        theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
 #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
 p=ggplot()+geom_line(
        data=ExG$df_res2,
        aes(x=ind,y=Value,group=Real,color=Real))+
        theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")

    }
    p
# }
}
})

}else{

  ggplot()+geom_line(
        data=EXG$df_res,
        aes(x=ind,y=Value,group=Comp,color=Comp))+
        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
}

if(shiny_running()){
    fillRow(
    #################STAGING TABLE FOR SELECTION
    fillCol(
      renderUI({
        ssas=graph_data$EEG
        pickerInput(
          inputId = "ssa_channel",
          choices =ssas,
          options = list(title = "Channels",`actions-box` = TRUE,size = 10),
          multiple = T
        )
      }),
      # DTOutput("stages"),flex=c(1,5)),
    # fillCol(
       switchInput(inputId = "time_real", label = "timed Realization", value=F),
      # renderUI({
      # if(!is.null(input$stages_rows_selected)){
      # if(input$stages_rows_selected==1){
      # ############################### UI ELEMENTS FOR SSA TO EACH STAGE OR
      knobInput(
        inputId = "neigs",
        label = "Number of Components",
        value = 20,
        max = 50,
        min=2,
        displayPrevious = TRUE,
        lineCap = "round",
        fgColor = "#428BCA",
        inputColor = "#428BCA",
        immediate=F
      ),
      #     }else{
      #
      # }
      # }
      # }),
      knobInput(
        inputId = "nclust",
        label = "Number of Clusters",
        value = 3,
        max = 20,
        min=1,
        displayPrevious = TRUE,
        lineCap = "round",
        fgColor = "#428BCA",
        inputColor = "#428BCA",
        immediate=F
      )

      ,flex=c(1,1,3,3)),
    ##########################GRAPHIC TO BE RENDERED
    plotOutput("telco",click = "plot_click"),flex=c(1,8))}


```


```{r, singular spectrum analysis}
# observeEvent(input$stages_rows_selected,
#
#              )

# observeEvent(input$nclust,{
#   for()
#
#   #vis_pipe$nodes=update_nodes_cluster(vis_pipe$nodes,ExG$gssa)
#   #vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#   ExG$rssa=recons(ExG$ssa,ExG$gssa[[i]])
#   # vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#
# })

## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK!
## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK!
if(shiny_running()){
observeEvent(c(input$ssa_channel,input$stages_rows_selected,input$neigs),{
  ExG$hold=1
#  if(!is.null(input$ssa_channel) & length(input$stages_rows_selected)==1){
  if(!is.null(input$ssa_channel)){
  ### 60 Minutes maximum
  # if(ExG$stages[input$stages_rows_selected+1,2]-ExG$stages[input$stages_rows_selected,2]<60){
    # tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],
    #                       start=ExG$stages[input$stages_rows_selected,2],
    #                       end=ExG$stages[input$stages_rows_selected+1,2]),25)
    tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],25)

    ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs)

    ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs))
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
    #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      #df$Column=input$stages_rows_selected
      ExG$df_res=rbind(ExG$df_res,df)
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      df=data.frame("ind"=seq(1,length(ExG$ssa$V[,1])))
      df[,paste0("Real",ExG$gssa[[i]])]=ExG$ssa$V[,ExG$gssa[[i]]]
      df=gather(df,key="Real",value = "Value",-ind)
      df=df[df$Real %in% paste0("Real",unlist(ExG$gssa[[i]])),]
      df$Real=factor(df$Real,levels = paste0("Real",unlist(ExG$gssa[[i]])))
      df$Row=i
#      df$Column=input$stages_rows_selected
      df$Column=input$stages_rows_selected
      ExG$df_res2=rbind(ExG$df_res2,df)
    }



  }
  ExG$hold=0
})

observeEvent(input$plot_click,{
  ExG$hold=1
  if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){
  #get the energy pattern
    if(ExG$pan==0){
      ExG$pan=c(input$plot_click$panelvar1,input$plot_click$panelvar2)
    }else{
      ##### Delete Component from Group
      ExG$gssa[[as.numeric(ExG$pan[1])]]=
        ExG$gssa[[as.numeric(ExG$pan[1])]][ExG$gssa[[as.numeric(ExG$pan[1])]]
                                           !=strsplit(ExG$pan[2],"Comp")[[1]][2]]
      ##### Add Component to Cluster
      ExG$gssa[[as.numeric(input$plot_click$panelvar1)]]=
        sort(as.numeric(append(
          ExG$gssa[[as.numeric(input$plot_click$panelvar1)]],strsplit(ExG$pan[2],"Comp")[[1]][2])))
    hlist=list()
    for(i in 1:length(ExG$gssa)){
      hlist[[i]]=ExG$gssa[[i]]
    }
    ExG$gssa=hlist
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
    #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      # df$Column=input$stages_rows_selected
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      ExG$df_res=rbind(ExG$df_res,df)
    }

      ExG$pan=0
    }
  }
  ExG$hold=0
})

observeEvent(input$nclust,{
  ExG$hold=1
  if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){
  ### 60 Minutes maximum
    ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs))
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
#    ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      # df$Column=input$stages_rows_selected
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      ExG$df_res=rbind(ExG$df_res,df)
    }
    ExG$hold=0
    }
})
}


######### THE OLD SSA WORKFLOW
# observeEvent(input$neigs,{
#   if(!is.null(input$ssa_channel) &!is.null(input$ssa_stages)){
#     if(input$ssa_stages!="All Stages"){
#   sels=strsplit(input$ssa_stages," ")[[1]][3]
#   # ExG$stages[,2] %in% sels
#
#   if(!to_day(ExG$posix,sels)){
#     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(ExG$posix)+1,sels)))
#   }else{
#     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(ExG$posix),sels)))
#   }
#   if(ExG$stages[i+1,2]-ExG$stages[i,2]<60){
#   tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],start=ExG$stages[i,2],end=ExG$stages[i+1,2]),25)
#   ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs)
#   #vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa)
#   }
#   }else{
#     tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],250)
#     arte=min(30,input$neigs)
#     ExG$ssa=ssa.svd(tmp,30,1,arte)
#    # vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa)
#   }
#   }
#   ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$neigs,input$nclust))
#   #vis_pipe$nodes=update_nodes_cluster(vis_pipe$nodes,ExG$gssa)
#   #vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#   ExG$rssa=recons(ExG$ssa,ExG$gssa)
# })



```


```{r}
# if(shiny_running()){
# #Editable stages
# observeEvent(input[["stages_cell_edit"]],{
#   tmp=input[["stages_cell_edit"]]
#   if(tmp$col==2){
#     if(length(strsplit(tmp$value,":")[[1]])>=2){
#       if(!to_day(ExG$posix,tmp$value)){
#         ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,tmp$value))
#       }else{ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),tmp$value))}
#     }
#     if(length(strsplit(tmp$value,":")[[1]])==2){
#       if(!to_day(ExG$posix,tmp$value)){
#         ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,paste0(tmp$value,":00")))
#       }else{ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),paste0(tmp$value,":00")))}
#     }
#   }else{ExG$stages[tmp$row,tmp$col]<-tmp$value}
#   ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),]
# })
# }
```



```{r}
if(shiny_running()){
  observeEvent(input$ana_button,{
  if(!is.null(input$ecg_ana)){
    res=py$qrs_detect(coredata(ExG$ts)[,input$ecg_ana],ExG$srate)
    ExG$qrs=data.frame(rep("QRS",length(res)),first(index(ExG$ts))+res)
    ExG$hrv=hrv_analysis(res,ExG$srate,mainDir)
  }
  if(!is.null(input$eeg_ana)){
    tmp_bp=rel_bp(coredata(ExG$freq)[,paste0("Filtered",input$eeg_ana)])
    ExG$bandpower=as.xts((tmp_bp[,1:5]/tmp_bp[,6])*100,seq(ExG$posix, by=input$L, length=nrow(tmp_bp)))
  ExG$spindles=NULL
  res2=data.frame()
  for(i in 1:(nrow(ExG$stages)-1)){
  ## Limit stages
    if((ExG$stages[i,1]%in% c("S1","S2","S3"))){
      ## For last entry take time to end, else take time to next stage
      if(i!=(nrow(ExG$stages)-1)){tmp=window(ExG$freq,start=ExG$stages[i,2],end=ExG$stages[i+1,2])
      }else{tmp=window(ExG$freq,start=ExG$stages[i,2],end=last(index(ExG$freq)))}
      ## Collect Sleep Spindles by Yasa
      res<-data.frame(
        py$sleep_spindles(tmp[,paste0("Filtered",input$eeg_ana)],ExG$srate),stringsAsFactors = F
        )[,c("Start","Duration","Oscillations")]

      res2=rbind(res2,data.frame(Start=ExG$stages[i,2]+res$Start,stringsAsFactors = F))
    }
  }
  ExG$spindles=setNames(
    data.frame(rep("Spindle",nrow(res2)),res2$Start,stringsAsFactors = F),c("Event","Time"))
  }
})
}

```


### Data Viewer & PDF - data is downsampled based on window range (a) more than 30 minutes (b) between 30 minutes and 20 seconds (c) less than 20 seconds

```{r}

if(shiny_running()){
fillRow(DTOutput("stages"),
renderTable({
  res=round(unlist(lapply(ExG$freq,function(x)nrow(x)/(ExG$srate*60)))[1],0)
res=c("Total",res)

df=data.frame("Stage"=ExG$stages[,1],"Duration"=c(as.numeric(difftime(c(ExG$stages[-1,2],last(index(ExG$freq))),ExG$stages[,2],units = "mins"))))

res2=ddply(df,"Stage",function(x)sum(x[,2]))
res2$Stage=as.character(res2$Stage)
res2$V1=round(res2$V1,0)
df_res=rbind(setNames(res,colnames(res2)),res2)

res3=t(py$glob_bp(array(coredata(ExG$freq[,paste0("Filtered",input$eeg_ana)])),ExG$srate))

res3=round(res3[1:6,]*100,1)
df_res=rbind(df_res,setNames(data.frame(names(res3),as.matrix(res3)),colnames(df_res)))
res4=nrow(ExG$spindles)
df_res=rbind(df_res,setNames(data.frame("Sleep Spindles",res4),colnames(df_res)))

res5=c("Explained Variance SSA",round(sum(contributions(ExG$ssa)*100),1))



ExG$summ=rbind(df_res,setNames(res5,colnames(df_res)))
ExG$summ
}))
}else{

kable(EXG$summ)

}



```


```{r}
if(shiny_running()){
observeEvent(input[["dygraph_click"]],{
  ## Add new row with inital Value Artifact to the EEG staging on click in graphic
  ## Get the Date
  if("Stages" %in% input$disp_event){
  date_click=strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][1]
  ## Get the Time, without the Z
  time_click=strsplit(strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][2],"Z")[[1]][1]
  ## Adjust format and timezone
  date_time_click=as.POSIXct(paste(date_click,time_click,format="%Y-%m-%d %H:%M:%OS"))+60*60
  ExG$stages=
    data.frame(rbind(ExG$stages,
          setNames(data.frame("A",
                              date_time_click,
                              stringsAsFactors = F),
                   colnames(ExG$stages))))
  }
})



observeEvent(input$downRater,{
  if(input$downRater!=0){
  downList=c("A","W","REM","S1","S2","S3")
  if(any(ExG$stages[as.numeric(input$downRater),1] %in% downList)){
     if(ExG$stages[as.numeric(input$downRater),1]!="S3"){
     ExG$stages[as.numeric(input$downRater),1]=
       downList[which(downList %in% ExG$stages[as.numeric(input$downRater),1] )+1]
     }else{
       ExG$stages=ExG$stages[-as.numeric(input$downRater),]
     }
  }
  }
})

observeEvent(input$upRater,{
  if(input$upRater!=0){
  upList=c("S3","S2","S1","REM","W","A")
  if(any(ExG$stages[as.numeric(input$upRater),1] %in% upList)){
    if(ExG$stages[as.numeric(input$upRater),1]!="A"){
      ExG$stages[as.numeric(input$upRater),1]=
      upList[which(upList %in% ExG$stages[as.numeric(input$upRater),1] )+1]
    }else{
      ExG$stages=ExG$stages[-as.numeric(input$upRater),]
    }
  }
  }
})
}

```

```{r}
################################### DYGRAPH EDIT FOR LARGE DATA #################################
################################### ERROR: DOES NOT DIGEST NEW DATA #################################
if(shiny_running()){
eventReactive({c(input[["dygraph_date_window"]])},
  {
    if(!ExG$newfile){
  ##Check current display ranges range,timezone conversion etc.
  r1=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[1]]),collapse = " "))+60*60
  r2=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[2]]),collapse = " "))+60*60
  range=c(r1,r2)
  d_range=difftime(range[2],range[1],units="secs")
  resize=F
  ## Resolution changed? "bird" -hour, "time"-minute, "detail" -second
  ## if so data need to be resampled resize=T
  if(d_range<60 & ExG$sight!="detail"){
    resize=T
    ExG$sight="detail"
  }
  if((d_range>=60 ) & ExG$sight!="time"){
    resize=T
    ExG$sight="time"
  }
  # if((d_range>=60*30 & d_range<60*60*24) & ExG$sight!="bird"){
  #   resize=T
  #   ExG$sight="bird"
  # }

  ## Update Resolution of data
  if(range[2]>min(last(index(ExG$orig.disp)),ExG$resol[2])||
     range[1]<max(first(index(ExG$orig.disp)),ExG$resol[1])||
     resize){
    ## if new data selection, dont change resolution borders
    # if(!ExG$redat){
    #
    # }else{
    #   r1=range[1]
    #   r2=range[2]
    # }
    r1=max(first(index(ExG$orig.disp)),range[1]-10*d_range)
    r2=min(last(index(ExG$orig.disp)),range[2]+10*d_range)
      #Seconds down to full
    if(ExG$sight=="detail"){
      if(r1!=first(index(ExG$orig.disp))){
        ## downsample out of scope to minutes, rest complete
          tmp=rbind(
            downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),60*ExG$srate*5),
            window(ExG$orig.disp,start=r1,end=r2))
      }else tmp=window(ExG$orig.disp,start=r1,end=r2)
      if(r2!=last(index(ExG$orig.disp))){
          tmp=rbind(tmp,
          downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),ExG$srate*60*5))}
      }
        # Minutes , down to seconds
    if(ExG$sight=="time"){
        if(r1!=first(index(ExG$orig.disp))){
          ## downsample out of scope to minutes, rest to seconds
          tmp=rbind(
              downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),ExG$srate),
              downsample(window(ExG$orig.disp,start=r1,end=r2),ExG$srate))
          }else tmp=downsample(window(ExG$orig.disp,start=r1,end=r2),ExG$srate)
          if(r2!=last(index(ExG$orig.disp))){
            tmp=rbind(tmp,
            downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),ExG$srate))}
    }
      # hours down to minutes
      # if(ExG$sight=="bird"){
      #   if(a!=first(index(ExG$orig.disp))){
      #       tmp=rbind(
      #         downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=a),250*60*10),
      #         downsample(window(ExG$orig.disp,start=a,end=b),250*60))
      #       }else{
      #           tmp=downsample(window(ExG$orig.disp,start=a,end=b),250*60)
      #         }
      #     if(b!=last(index(ExG$orig.disp))){
      #       tmp=rbind(tmp,
      #       downsample(window(ExG$orig.disp,start=b,end=last(index(ExG$orig.disp))),250*60*10))
      #       }
      # }
      ExG$resol=c(r1,r2)
      ExG$disp=tmp
  }
    }else{
      Sys.sleep(5)
       ExG$newfile=F
     }
})
}

if(shiny_running()){
observeEvent({c(input$disp_chan,
                input$disp_event,
                input$disp_ssa)},
  {
  # Select Channels to display - mutually exclusive for Source and Channel
  if(!is.null(input$disp_chan)){
    ## Check for mutually exclusive groups - not working
    if(!all(paste0("Filtered",input$disp_chan) %in% colnames(ExG$orig.chan))|
       !all(colnames(ExG$orig.chan) %in% paste0("Filtered",input$disp_chan))){newdata=T}else{newdata=F}
  }else{
    if(!is.null(colnames(ExG$orig.chan))){newdata=T}else{newdata=F}
  }

  #if anything is not displayed already
  if(newdata){
    tmp=xts(rep(NA,length(index(ExG$freq))),index(ExG$freq))
    colnames(tmp)="Empty"
    if(!is.null(input$disp_chan)){
      for(i in 1:length(input$disp_chan)){
          tmp=merge(tmp,ExG$freq[,paste0("Filtered",input$disp_chan[i])])
      }
    ExG$orig.chan=tmp[,colSums(is.na(tmp))<1000]
    }else{
    ExG$orig.chan=tmp
    }
    # ExG$colors=c("#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#005a32")[
    #   colnames(ExG$freq) %in% sort(paste0("Filtered",input$disp_chan))
    # ]
  }
  newclust=(!all(input$disp_ssa %in% colnames(ExG$orig.ssa)))|
    (!all(colnames(ExG$orig.ssa) %in% input$disp_ssa))
  if(newdata|newclust){
    tmp=ExG$orig.chan
    # if(input$clust_disp){
      # ExG$rssa<-recons(ExG$ssa,ExG$gssa,stacked = F)
    # }else{
    #   ExG$rssa<-recons(ExG$ssa,ExG$gssa,separate = T)
    #}
    for(i in input$disp_ssa){
      tmp=merge(tmp, ExG$rssa[,i])
    }
    ExG$orig.ssa=tmp
  }

  ## Check if alpha band is already displayed, not clean
  test_q1=(!any(grepl("BP",colnames(ExG$orig.disp))) & "Bandpower" %in% input[["disp_event"]])|
      (any(grepl("BP",colnames(ExG$orig.disp))) & !("Bandpower" %in% input[["disp_event"]]))

  # Check not implemented
  # test_q2=(all(graph_data$EEG %in% colnames(ExG$orig.disp)) & !("Raw Signal" %in% input$disp_event))|
  #               (!all(graph_data$EEG %in% colnames(ExG$orig.disp)) & ( "Raw Signal" %in% input$disp_event))

  if(test_q1|newdata|newclust){
    # if(input$clust_disp){}
    tmp=ExG$orig.ssa
    # if("Raw Signal" %in% input$disp_event){
    #   tmp=merge(tmp,ExG$ts[,unlist(lapply(strsplit(colnames(ExG$orig.chan),"Filtered"),function(x)x[[2]]))])   }
  if("Bandpower" %in% input$disp_event){tmp=merge(tmp,ExG$bandpower)}
    ##Downsample already
    ExG$orig.disp=list("bird"=downsample(tmp,250*5),"minute"=downsample(tmp,250),"detail"=tmp)
  }
  # switch for resolution
  # if(ExG$redat==F){ExG$redat=T}else{ExG$redat=F}
  
  
  r1=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[1]]),collapse = " "))+60*60
  r2=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[2]]),collapse = " "))+60*60
  range=c(r1,r2)
  d_range=difftime(range[2],range[1],units="secs")
  # if(ExG$sight=="detail"){
  #     if(r1!=first(index(ExG$orig.disp))){
  #       ## downsample out of scope to minutes, rest complete
  #         tmp=rbind(
  #           downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),60*ExG$srate*5),
  #           window(ExG$orig.disp,start=r1,end=r2))
  #     }else tmp=window(ExG$orig.disp,start=r1,end=r2)
  #     if(r2!=last(index(ExG$orig.disp))){
  #         tmp=rbind(tmp,
  #         downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),ExG$srate*60*5))}
  #     }
  #       # Minutes , down to seconds
  #   if(ExG$sight=="time"){
  #       if(r1!=first(index(ExG$orig.disp))){
  #         ## downsample out of scope to minutes, rest to seconds
  #         tmp=rbind(
  #             downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),ExG$srate),
  #             downsample(window(ExG$orig.disp,start=r1,end=r2),ExG$srate))
  #         }else tmp=downsample(window(ExG$orig.disp,start=r1,end=r2),ExG$srate)
  #         if(r2!=last(index(ExG$orig.disp))){
  #           tmp=rbind(tmp,
  #           downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),ExG$srate))}
  #   }
    ExG$resol=c(r1,r2)
    ExG$disp=tmp

    })
}
```


```{r}


# if(shiny_running()){
#   # dropdown(
#   # tags$h3("List of Input"),
#   renderUI({
#     chansels=colnames(ExG$ts)
#   pickerInput(
#     inputId = "disp_chan",
#     label = "Select Channels/Sources for Glimpse",
#     choices =chansels,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
#   })
# }
#   #,
# if(shiny_running()){
#
# pickerInput(
#     inputId = "disp_event",
#     label = "Select Events/Filters for Glimpse",
#     choices = c("Raw Signal","Bandpower","Stages","Events"),
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
# }
#   #,
# # if(shiny_running()){
# #
# # pickerInput(
# #     inputId = "excl_sigs",
# #     label = "Select Exclusion Periods for Glimpse",
# #     choices = c("W","S1","S2","S3","REM"),
# #     options = list(
# #     `actions-box` = TRUE,
# #     size = 10,
# #     `selected-text-format` = "count > 3"
# #   ),
# #   multiple = TRUE
# #   )
# # }
# if(shiny_running()){
# renderUI({
# sel_choices=colnames(ExG$rssa)
# pickerInput(
#     inputId = "disp_ssa",
#     label = "Select Clusters/Components for Glipse",
#     choices = sel_choices,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
#
# })
# }
#
# if(shiny_running()){
#   switchInput(inputId = "sep_chan", label = "parallel Channels", value=F)
# }
#
#


```

```{r}
if(shiny_running()){
  downloadButtonRmd("downloadReport",label="Download PDF")
}

# renderPrint(print(getwd()))

if(shiny_running() ){
output$downloadReport <- downloadHandler(
  filename = function() {
    paste('MentaLab', sep = '.', PDF = 'pdf')
  },
  content = function(file){
    file.copy(paste0(mainDir,"/Dashboard.Rmd"),
              paste0(mainDir,"/Report.Rmd"), overwrite = TRUE)
    # nok=isolate(ExG$stages)
    EXG<<-list()
    EXG$stages=ExG$stages
    EXG$df_res=ExG$df_res
    EXG$spindles=ExG$spindles
    EXG$hrv=ExG$hrv
    EXG$summ=ExG$summ
    out=rmarkdown::render(paste0(mainDir,"/Report.Rmd"), pdf_document(),runtime="static")
    file.rename(out, file)
  })}

```


